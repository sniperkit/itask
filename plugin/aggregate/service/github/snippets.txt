
============================================================================================================
if v := r.Header["Retry-After"]; len(v) > 0 {
	// According to GitHub support, the "Retry-After" header value will be
	// an integer which represents the number of seconds that one should
	// wait before resuming making requests.
	retryAfterSeconds, _ := strconv.ParseInt(v[0], 10, 64) // Error handling is noop.
	retryAfter := time.Duration(retryAfterSeconds) * time.Second
	abuseRateLimitError.RetryAfter = &retryAfter
}

============================================================================================================
func (g *Github) getClient(token string) *github.Client {
	g.mc.Lock()
	defer g.mc.Unlock()

	if g.ctoken == "" {
		g.ctoken = token
	}

	resetClient := false

	if g.ctoken != token {
		g.ctoken = token
		resetClient = true
	}

	if g.client == nil {
		resetClient = true
	}

	if g.rateLimiters == nil {
		g.rateLimiters = make(map[string]*rate.RateLimiter, len(g.tokens))
	}

	// g.rateLimiter().Wait()
	log.Println("#1 / g.ctoken=", g.ctoken, "resetClient=", resetClient, "g.xcache=", g.xcache == nil)

	if g.xcache == nil {
		var err error

		util.EnsureDir(CachePrefixPath)
		CacheEngine = strings.ToLower(CacheEngine)

		switch CacheEngine {
		case "diskv":
			cacheStoragePrefixPath := filepath.Join(CachePrefixPath, "cacher.diskv")
			util.EnsureDir(cacheStoragePrefixPath)
			g.xcache = diskcache.New(cacheStoragePrefixPath)

		case "badger":
			cacheStoragePrefixPath := filepath.Join(CachePrefixPath, "cacher.badger")
			util.EnsureDir(cacheStoragePrefixPath)
			g.xcache, err = badgercache.New(
				&badgercache.Config{
					ValueDir:    "api.github.com.v3.snappy",
					StoragePath: cacheStoragePrefixPath,
					SyncWrites:  false,
					Debug:       false,
					Compress:    true,
				})

		case "memory":
			g.xcache = httpcache.NewMemoryCache()

		default:
			g.xcache = nil

		}

		if err != nil {
			log.Fatal("cache err", err.Error())
		}

	}

	log.Println("#2 / g.ctoken=", g.ctoken, "resetClient=", resetClient, "g.xcache=", g.xcache == nil)

	if g.client != nil && !resetClient {
		return g.client
	}

	var hc http.Client

	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)

	/*
		ts := oauth2.ReuseTokenSource(nil,
			oauth2.StaticTokenSource(
				&oauth2.Token{AccessToken: token},
			),
		)
	*/

	t := httpcache.NewTransport(g.xcache)
	t.MarkCachedResponses = true

	hc.Transport = httpstats.NewTransport(t)
	// timeout := time.Duration(10 * time.Second)

	/*
		hc4github := &http.Client{
			Transport: &oauth2.Transport{
				Base: hc.Transport,
				Source: oauth2.ReuseTokenSource(nil, oauth2.StaticTokenSource(
					&oauth2.Token{AccessToken: token},
				)),
			},
			CheckRedirect: hc.CheckRedirect,
			Jar:           hc.Jar,
			Timeout:       hc.Timeout,
		}

		transport.Transport = &github.UnauthenticatedRateLimitedTransport{
			ClientID:     id,
			ClientSecret: secret,
		}
	*/

	// tc = oauth2.NewClient(oauth2.NoContext, ts)
	ghClient := github.NewClient(&http.Client{
		Transport: &oauth2.Transport{
			Base:   hc.Transport,
			Source: ts,
		},
		// CheckRedirect: hc.CheckRedirect,
		// Jar:           hc.Jar,
		// Timeout:       hc.Timeout,
		// Timeout: timeout,
	})

	g.client = ghClient

	return g.client
}

============================================================================================================
func getClient(token string) *github.Client {
	if token != "" {
		var err error
		util.EnsureDir(CachePrefixPath)
		CacheEngine = strings.ToLower(CacheEngine)

		switch CacheEngine {
		case "diskv":
			cacheStoragePrefixPath := filepath.Join(CachePrefixPath, "cacher.diskv")
			util.EnsureDir(cacheStoragePrefixPath)
			xcache = diskcache.New(cacheStoragePrefixPath)

		case "badger":
			cacheStoragePrefixPath := filepath.Join(CachePrefixPath, "cacher.badger")
			util.EnsureDir(cacheStoragePrefixPath)
			xcache, err = badgercache.New(
				&badgercache.Config{
					ValueDir:    "api.github.com.v3.snappy",
					StoragePath: cacheStoragePrefixPath,
					SyncWrites:  false,
					Debug:       false,
					Compress:    true,
				})

		case "memory":
			xcache = httpcache.NewMemoryCache()

		default:
			xcache = nil

		}

		if err != nil {
			log.Fatal("cache err", err.Error())
		}

		var hc http.Client
		ts := oauth2.StaticTokenSource(
			&oauth2.Token{AccessToken: token},
		)

		// t := httpcache.NewBlockingTransport(nil)
		// t := httpcache.NewTransport(transport)
		t := httpcache.NewTransport(xcache)
		t.MarkCachedResponses = true
		// t.Transport = httpcache.NewBlockingTransport(nil)

		/*
			transport := &apiproxy.RevalidationTransport{
				Transport: t,
				Check: (&githubproxy.MaxAge{
					User:         time.Hour * 24,
					Repository:   time.Hour * 24,
					Readme:       time.Hour * 24,
					Languages:    time.Hour * 24,
					Topics:       time.Hour * 24,
					Repositories: time.Hour * 24,
					Activity:     time.Hour * 12,
				}).Validator(),
			}
		*/
		// hc.Transport = transport
		// hc.Transport = t

		/*
			influxConfig = influxdb.ClientConfig{
				Database:   "limo-httpstats",
				Address:    "127.0.0.1:8086",
				BufferSize: 2 * 1024 * 1024,
				Timeout:    5 * time.Second,
			}
			influxClient = influxdb.NewClientWith(influxConfig)
			influxClient.CreateDB("limo-httpstats")

			// stats.Register(influxClient)
			// defer stats.Flush()
			statsEngine = stats.NewEngine("limo", influxClient, statsTags...)
			// register engine
			// statsEngine.Register(influxClient)
			// defer statsEngine.Flush()

			hc.Transport = httpstats.NewTransportWith(statsEngine, t)
		*/

		hc.Transport = httpstats.NewTransport(t)
		// timeout := time.Duration(10 * time.Second)

		ghClient := github.NewClient(&http.Client{
			Transport: &oauth2.Transport{
				Base:   hc.Transport,
				Source: ts,
			},
			//Timeout: timeout,
		})

		return ghClient
	}

	return github.NewClient(nil)
}